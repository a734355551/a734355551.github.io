<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>feng&#39;s blog</title>
  
  <subtitle>不忘初心 方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-01T02:31:23.522Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>feng zhenting</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/03/01/hello-world/"/>
    <id>http://yoursite.com/2019/03/01/hello-world/</id>
    <published>2019-03-01T02:31:23.522Z</published>
    <updated>2019-03-01T02:31:23.522Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://yoursite.com/2019/01/29/Java%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/01/29/Java集合/</id>
    <published>2019-01-29T02:39:00.000Z</published>
    <updated>2019-01-29T07:21:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合框架介绍"><a href="#Java集合框架介绍" class="headerlink" title="Java集合框架介绍"></a>Java集合框架介绍</h2><p>Java的集合框架有下图所示：</p><p> <img src="https://raw.githubusercontent.com/shuangshuangshuangfeng/shuangshuangshuangfeng.github.io/master/2019/01/29/Java%E9%9B%86%E5%90%88/java%E9%9B%86%E5%90%88.png" alt="Java集合继承关系图"><br><a id="more"></a></p><h3 id="Collection-有序接口"><a href="#Collection-有序接口" class="headerlink" title="Collection 有序接口"></a>Collection 有序接口</h3><h4 id="Collection的主要方法有"><a href="#Collection的主要方法有" class="headerlink" title="Collection的主要方法有:"></a>Collection的主要方法有:</h4><ul><li>boolean add(Object o)添加对象到集合</li><li>boolean remove(Object o)删除指定对象</li><li>int size() 返回当前集合中的元素</li><li>boolean contains(Object O)查找集合中是否有指定对象</li><li>boolean isEmpty() 判断集合是否为空</li><li>Iterator iterator() 返回一个迭代器</li><li>boolean containsAll(Collection c) 查找集合中是否含有集合c的元素</li><li>boolean addAll(Collection c) 将集合c中的元素添加至集合中</li><li>void clear() 删除集合中的所有元素</li><li>void removeAll(Collection c)从集合中删除c集合中也有的元素</li><li>void retainAll(Collection c)从集合中删除集合c中不包含的元素</li></ul><h3 id="List抽象接口"><a href="#List抽象接口" class="headerlink" title="List抽象接口"></a>List抽象接口</h3><p>List抽象接口可以重复有序</p><h4 id="List的主要方法"><a href="#List的主要方法" class="headerlink" title="List的主要方法"></a>List的主要方法</h4><ul><li>void add(int index, Object element)在指定位置添加一个元素</li><li>boolean addAll(int index, Collect c)将集合c中的元素添加到指定的位置</li><li>Object get(int index) 返回List中某个指定位置的元素</li><li>int indexOf(Object o) 返回第一个出现元素o的位置</li><li>Object remove(int index)删除指定位置的元素</li><li>Object set(int index, Object element)用元素element取代位置为index上的元素，返回被取代的元素</li><li>void sort() 排序</li></ul><h4 id="List主要接口对象"><a href="#List主要接口对象" class="headerlink" title="List主要接口对象"></a>List主要接口对象</h4><ul><li>LinkedList没有同步方法</li><li>ArrayList是非同步的</li><li>Vector是同步的(synchronized)，类似于ArrayList</li></ul><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>Java中使用Set接口的集合不允许有重复值,也就是说Set中的每一个元素都是唯一的。</p><h4 id="Set的主要方法"><a href="#Set的主要方法" class="headerlink" title="Set的主要方法"></a>Set的主要方法</h4><ul><li>int size() 获取集合中元素的个数</li><li>add(Object o)向集合中添加元素</li><li>Object remove(Object o) 在集合中删除元素o</li><li>boolean contains(Object o) 判断集合中是否含有元素o</li><li>iterator() 排序</li></ul><h4 id="Set接口的实现类-HashSet"><a href="#Set接口的实现类-HashSet" class="headerlink" title="Set接口的实现类-HashSet"></a>Set接口的实现类-HashSet</h4><p><strong>HashSet通过Hash算法排布集合内的元素，是一个无序，不可重复的集合。</strong></p><ul><li>HashSet不能保证元素的顺序，不可重复，不是线程安全的，集合元素可以为Null.</li><li>其底层实现实际上是一个数组，存在的意义就是加快查询速度.</li><li>对于HashSet集合中存在两个对象通过equals()方法返回true,那么这两个对象的hashCode值也应该相同。</li></ul><p><strong>注意</strong>: 每一个存储到哈希表中的对象，都要提供hashCode()和equals()方法的实现，用来判断是否是一个对象。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map接口的实现类有：HashMap, Hashtable，TreeMap。</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度.HashMap最多只允许一条记录的键为Null(多条会覆盖);允许多条记录的值为 Null，非同步的。</p><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>与HashMap类似，不同的是key和value的值均不允许为null，他支持线程的同步.即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtale在写入时会比较慢。</p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 </p><h2 id="有关集合的面试题"><a href="#有关集合的面试题" class="headerlink" title="有关集合的面试题"></a>有关集合的面试题</h2><ol><li><p><strong>List初始化大小</strong>:<br>List arrayList = new ArrayList();<br>如果使用默认的构造方法，初始容量被设置为10，当ArrayList中的元素超过10个的时候，会使数组的大小增长到16.<br>通过调试可以看的到动态增长的数量变化是: 10-&gt;16-&gt;25-&gt;38-&gt;58-&gt;88-&gt;…<br>增长的计算公式为: 新容量 = (旧容量*3)/2+1</p></li><li><p><strong>ArrayList和Vector(旧的)</strong>的区别:<br><strong>共同点</strong>: 这两个类都实现了List接口，他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复。<br><strong>区别</strong>:</p></li></ol><ul><li>同步性: Vector是线程安全的，也就是说他们的方法之间是线程同步的，而ArrayList是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li><li>数据增长:ArrayList与Vector都有一个初始的容量大小，当存储进他们里面的元素超过了容量的时候,就需要增加ArrayList与Vector的存储空间。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 </li></ul><ol start="3"><li>HashMap与Hashtable的区别:</li></ol><ul><li>Hashtable是基于陈旧的Dictionary类， HashMap是Java 1.2引进的Map接口的一个实例。</li><li>Hashtable是同步的，是线程安全的。HashMap是不同步的，非线程安全。</li><li>HashMap可以允许空值，Hashtable不允许空值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java集合框架介绍&quot;&gt;&lt;a href=&quot;#Java集合框架介绍&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架介绍&quot;&gt;&lt;/a&gt;Java集合框架介绍&lt;/h2&gt;&lt;p&gt;Java的集合框架有下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/shuangshuangshuangfeng/shuangshuangshuangfeng.github.io/master/2019/01/29/Java%E9%9B%86%E5%90%88/java%E9%9B%86%E5%90%88.png&quot; alt=&quot;Java集合继承关系图&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://yoursite.com/2018/12/24/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/24/Java基础/</id>
    <published>2018-12-24T06:03:30.000Z</published>
    <updated>2019-01-21T09:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>va基础知识回顾</p><ol><li><p>JVM, JRE, JDK的区别</p><p> JVM（java Virtual Machine）:java虚拟机，用于保证java的跨平台性</p><p> JRE（Java Runtime Environmen）:java运行环境，包括JVM+Jave的系统类库</p><p> JDK（Java Development Kit）:Java的软件开发工具包, 他包含了Java的运行环境(JVM+Java系统类库)和Java工具</p></li><li><p>环境变量Path和ClassPath的作用和区别<br> Path: 是配置可执行文件的搜索路径，当执行.exe文件时回去Path指定的路径查找可执行文件</p><p> ClassPath: 是配置class文件所在的目录，用于指定类的搜索路径，JVM是通过ClassPath查找类的</p></li></ol><a id="more"></a><p>3.关于java大小端的问题</p><p>这个问题起源于一次滴滴面试，当时面试官问到这个问题的时候一脸蒙逼，只怪自己学识太浅，仍需要加倍努力。</p><p><strong>什么是大端和小端</strong></p><p>大端模式:数据的高字节保存在内存的低地址中,数据的低字节保存在内存的高地址中。</p><p>小端模式:数据的高字节保存在内存的高地址中，数据的低字节保存在内存的低地址中。</p><p>记忆方式:”小端低低”</p><p><strong>之所以有大小端之分，是因为:</strong></p><p>计算机中是以字节为单位的，每个地址单元都对应一个字节(8bit)，而在C语言，c++..的语言中，除了8bit的char类型，还有int,long float等类型,由于寄存器是大于一个字节的，所以，必然存在着怎样存放数据的问题，也就有了大端和小端。</p><p>大端和小端的问题和计算机使用的芯片有关，目前Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换，同时大端和小端的处理还与编译器的实现有关，在C语言中，默认是小端，由于Java是与平台无关的，所以Java默认是大端。</p><ol start="4"><li><p>重载：</p><p> 概念：在同一个类中，允许存在一个以上的同名<br> 函数，只要他们的参数个数或者参数类型不同</p><p> 特点：返回值与类型无关,只看参数列表</p><p> <code>public void testOverload(int a){ }</code></p><p> <code>public void testOverload(String a){ }</code></p><p><code>public void testOverload(int a, int b){}</code></p></li><li><p>构造方法和普通方法的区别:</p><p> 构造方法和类名相同，并且没有返回类型，也没返回值</p><p> 普通方法可以任意起名，必须有返回类型</p></li><li><p>this 和super的区别:</p><p> this代表本类对象的引用</p><p> super代表父类的存储空间</p></li><li><p>equals 和 == 的区别:</p><p> ==: 比较的是变量的内存地址, 也就是看这两个对象是否是一个对象</p><p> equals: 比较的是两个对象的内容是否一样，当一个类中，没有对equals()方法进行覆盖，那么使用的是Object类中的equals()方法，而Object类中的equals()方法返回的就是 == 的判断。</p></li><li><p>HashCode:<br> hashCode() 是Object类中的一个方法， 在Java中，hashCode() 方法主要作用是: 配合基于散列的集合一起使用，这样的散列集合包括: HashSet, HashMap Hashtable。</p><p> Java中的hashCode() 方法，是根据一定的规则，将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作散列值。</p></li><li><p>hashCode() 与 equals() 方法:</p><p> 首先要明白: <strong>如果两个对象的hashCode值相等，不能确定两个对象相等。</strong></p><p> 在程序执行期间，只要equals()方法的比较操作得到的信息没有被修改，那么对同一个对象调用多次，hashCode()方法必须返回同一个值。</p><p> 如果两个对象根据equals() 方法比较是相等的，那么调用hashCode()必须返回相同的值</p><p> 如果两个对象根据equals() 方法比较是不相等的，但是hashCode() 不一定不相同</p><p> 因此要记得: <strong>当重写equals() 方法的时候，记得重写hashCode()方法。</strong></p></li></ol><ol start="11"><li><p>Object类中的方法</p><p>  <code>public native int hashCode();</code></p><p>  <code>public boolean equals(Object obj) {return (this == obj);}</code></p><p>  <code>protected native Object clone() throws CloneNotSupportedException;</code></p><p>  <code>public String toString() {return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); }</code></p><p> <code>public final native Class&lt;?&gt; getClass()</code></p><p> <code>protected void finalize() throws Throwable { }</code></p><p> <code>public final native void notify();</code></p></li></ol><ol start="12"><li><p>反射机制</p><p>Java反射机制：在运行状态中，对任意一个实体类,都能知道这个类的属性和方法，对于任意个个对象，都能调用他的任意方法和属性，这种动态获取信息以及动态调用对象的方法的功能称作Java反射机制.</p><p>类型信息:</p><p>Java让我们在运行时识别对象和类的信息，有两种方式:一种是RTTI（Run-Time Type Information)，它假定我们在编译时已经知道了所有类型信息; 一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><p>RTTI，编译器在编译时打开和检查.class文件 </p><p>反射，运行时打开和检查.class文件</p></li><li><p>Java类加载</p><p>当程序要使用某个类时，如果该类还未被加载到内存中， 系统会通过<strong>加载–&gt;连接–&gt;初始化</strong>三步对这个类进行初始化。</p><p>加载 : 将class文件读入内存，并为之创建一个Class对象（任何类在被使用时，系统都会为它建立一个Class对象）。</p><p>连接 : </p><p>验证： 确保加载类的正确性</p><p>准备： 负责为类的静态成员分配内存，并设置默认初始化值</p><p>解析： 将类中的符号引用替换为直接引用</p><p>初始化 : 局部变量保存在栈区,不许手动初始化，new的对象保存在堆区，虚拟机会进行默认初始化。 </p></li></ol><ol start="14"><li><p>Java对象的生命周期</p><ol><li>创建阶段</li><li>应用阶段</li><li>不可见阶段</li><li>不可达阶段</li><li>收集阶段</li><li>终结阶段</li><li>对象空间重分配阶段</li></ol></li><li><p>String, StringBuilder, StringBuffer</p><ol><li><p>运行速度比较 : String &lt; StringBuffer &lt; StringBuilder</p></li><li><p>线程安全 : StringBuffer是线程安全的，StringBulider是线程不安全的</p></li><li><p>使用范围 : </p><p> String 适用于少量字符串使用</p><p> StringBuffer适用多线程下字符缓冲区进行大量操作</p><p> StringBulider适用单线程下字符缓冲区进行大量操作</p></li></ol></li><li><p>重载和重写的区别</p><p>重写是子类重写父类方法</p><p>重载是一个类中含有多个同名函数，其参数列表不同</p></li><li><p>Java对象的序列化与反序列化</p><p>Java对象是只存在于虚拟机中的堆内存中的，如果要保存对象的状态，就用到了Java序列化，能够使Java对象持久化。</p><p>Java序列化机制是Java语言内建的一种对象持久化机制。通过对象序列化，将对象的状态保存在字节数组中。</p><p>对象反序列化就是将字节数组转化为JVM中活动的对象。</p></li></ol><ol start="18"><li><p>多线程</p></li><li><p>synchronized 锁定的是对象，而不是代码。对于非static的synchronized党法，锁的是对象本身也就是this，对于static的方法，相当于锁定了代码段。</p><p> 对于加了synchronized的的这段代码称为互斥区或者临界区。</p></li><li><p>同步方法和非同步方法是否可以同步调用： 可以的，同步方法需要锁，不同步方法不需要锁，两者不冲突。</p></li><li><p>对业务写方法加锁，对业务读方法没有加锁，容易出现脏读问题。（解决脏读问题的一个方法 : CopyOnRight）</p></li><li><p>线程安全概念: 当多个线程访问某一个类（或对象，或方法）时，这个类始终能表现出正确的行为，那么这个类(对象或方法)就是线程安全。</p></li><li><p>实现线程的两种方式:</p><p> 继承Thread类</p><p> 实现Runnable接口</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;va基础知识回顾&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JVM, JRE, JDK的区别&lt;/p&gt;
&lt;p&gt; JVM（java Virtual Machine）:java虚拟机，用于保证java的跨平台性&lt;/p&gt;
&lt;p&gt; JRE（Java Runtime Environmen）:java运行环境，包括JVM+Jave的系统类库&lt;/p&gt;
&lt;p&gt; JDK（Java Development Kit）:Java的软件开发工具包, 他包含了Java的运行环境(JVM+Java系统类库)和Java工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;环境变量Path和ClassPath的作用和区别&lt;br&gt; Path: 是配置可执行文件的搜索路径，当执行.exe文件时回去Path指定的路径查找可执行文件&lt;/p&gt;
&lt;p&gt; ClassPath: 是配置class文件所在的目录，用于指定类的搜索路径，JVM是通过ClassPath查找类的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
